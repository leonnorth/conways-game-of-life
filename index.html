<html>
  <head>
    <title></title>
    <meta content="">
    <style></style>
    <link href="css/style.css" rel="stylesheet" />   
  </head>
  <body>
  	<script src="https://cdnjs.cloudflare.com/ajax/libs/d3/3.5.6/d3.min.js" charset="utf-8"></script>
  	<script>
  	var width,
  		height,
  		svgContainer,
  		arrayA,
  		arrayB,
  		arrayWidth,
  		arrayHeight,
  		squareSize,
  		toggle,
  		remainderXBuffer,
  		remainderYBuffer;


  	function init(){
  		squareSize = 10;
  		// width = window.innerWidth;
  		// height = window.innerHeight;
      width = 40;
      height = 40;

  		initArrays();

  		toggle = true;
  		remainderXBuffer = (width - arrayWidth * squareSize) / 2 + squareSize/2;
  		remainderYBuffer = (height - arrayHeight * squareSize) / 2 + squareSize/2;

  		svgContainer = d3.select("body")
  			.append("svg");
      
  		draw();
  	}

  	function initArrays(){

  		// calculate array size
  		arrayWidth = parseInt( width / squareSize );
  		arrayHeight = parseInt( height / squareSize );
  		console.log("arrayWidth: "+arrayWidth+" arrayHeight: "+arrayHeight);

  		// initialise arrays to false
  		arrayA = arrayB = new Array(arrayWidth);
  		for (var i = 0; i < arrayWidth; i++){
  			arrayA[i] = arrayB[i] = new Array(arrayHeight);
  			for (var j = 0; j < arrayHeight; j++){
  				arrayA[i][j] = arrayB[i][j] = {"alive":false};
  			} 
  		}
      // console.log(arrayA);
  		// seed arrayA
  		// arrayA[1][1].alive = arrayA[1][2].alive = arrayA[1][3].alive = arrayA[1][0].alive = true;
      arrayA[1][1].alive = true;


  		// console.log(arrayA);
  	}



  	function draw(){
  		//background
  		svgContainer.append("rect")
  			.attr("width", "100%")
  			.attr("height", "100%")
  			.attr("fill", "pink");
      drawInit();
  		run();
      // tempDraw();
  	}

    function tempDraw(){
      var data = [30];
      svgContainer.selectAll("g")
        .data(data)
        .enter()
        .append("circle")
        .attr("cx", 60)
        .attr("cy", 100)
        .attr("r", function(d){ return d;})

        var count = 0;
        var running = setInterval(function(){

          data[0] = data[0] - 1;

            svgContainer.selectAll("circle")
            .data(data)
            .enter()
            .transition()
            .attr("r", function(d){ return d;});

          if(count++ == 10){done()};

        },500);
        function done(){
          console.log("done");
          clearInterval(running);      
        }
    }

    function drawInit(){
      svgContainer.selectAll("g")
        .data(arrayA)
        .enter()
        .append("g")
        .selectAll("circle")
        .data( function(d, i, j){ return d;})
        .enter()
        .append("circle")
        .attr("cx", function(d, i, j){ return j * squareSize + remainderXBuffer ;})
        .attr("cy", function(d, i, j){ return i * squareSize + remainderYBuffer ;})
        .attr("r", function(d,i){
            if (d.alive){ return 5;} else {return 1;} 
          ;})
    }

  	function run(){
  		var count = 0;
  		var running = setInterval(function(){
          drawTick();
          tick();
          if(count++ == 10){done()};

        },500);
        function done(){
        	console.log("done");
          clearInterval(running);      
        } 
  	}

  	function tick(){

  		console.log("tick");

      //clear arrayB
      for (row = 0; row < arrayWidth; row++){
        for (col = 0; col < arrayHeight; col++){
          arrayB[col][row].alive = false;
        }
      }
      // console.log(arrayB);

  		//create next array
  		for (row = 0; row < arrayWidth; row++){
  			for (col = 0; col < arrayHeight; col++){
  				var aliveNeighbours = checkNeighbours(row, col);
			// Any live cell with fewer than two live neighbours dies, as if caused by under-population.
				if(arrayA[row][col].alive && aliveNeighbours < 2){
					console.log("a");
					arrayB[row][col].alive = false;}
			// Any live cell with two or three live neighbours lives on to the next generation.
				else if(arrayA[row][col].alive && aliveNeighbours < 4){
					console.log("b");
					arrayB[row][col].alive = true;}
			// Any live cell with more than three live neighbours dies, as if by overcrowding.
				else if(arrayA[row][col].alive){
					console.log("c");
					arrayB[row][col].alive = false;}
			// Any dead cell with exactly three live neighbours becomes a live cell, as if by reproduction.
				else if(!arrayA[row][col].alive && aliveNeighbours === 3){
					console.log("d");
					arrayB[row][col].alive = true;}
  			}
  		}
      // console.log(arrayB);

  		//set array
      for (row = 0; row < arrayWidth; row++){
        for (col = 0; col < arrayHeight; col++){
          arrayA[col][row].alive = arrayB[col][row].alive;
          console.log(arrayA[col][row].alive);
        }
      }
  		// arrayA = arrayB;
    //   console.log(arrayA);
  	}

  	//count number of surrounding neighbours
  	function checkNeighbours(row, col){
		//function for using modulo and keeping output positive
  		Number.prototype.mod = function(n) { return ((this%n)+n)%n; }

  		var neighbours = 0;
  		for (i = 0; i < 3; i++){
  			for (j = 0; j < 3; j++){
  				
  				var x = (col + 1 - i).mod(arrayHeight);
  				var y = (col + 1 - j).mod(arrayWidth);
  				if (arrayA[x][y].alive){
  					neighbours++;
  				}
  			}
  		}
  		// console.log("neighbours:"+neighbours);
  		return neighbours;
  	}

  	function drawTick(){
      //background
      // svgContainer.append("rect")
      //   .attr("width", "100%")
      //   .attr("height", "100%")
      //   .attr("fill", "pink");
      // drawInit();

  		d3.selectAll("circle")
  			.data(arrayA)
  			// .selectAll("circle")
  			.data( function(d){ return d;})
  			// .enter()
  			// .append("circle")
  			// .attr("cx", function(d, i, j){ return j * squareSize + remainderXBuffer ;})
  			// .attr("cy", function(d, i, j){ return i * squareSize + remainderYBuffer ;})
  			.transition()
        .attr("r", function(d){
	  				if (d.alive){ return 5;} else {return 1;} 
	  			;})
  	}

  	init();

  	</script>

  </body>
</html>